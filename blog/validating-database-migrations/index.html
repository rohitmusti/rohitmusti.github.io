<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2bbc0921d5656d23.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2bbc0921d5656d23.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-45f9f9587e6c08e1.js" defer=""></script><script src="/_next/static/chunks/framework-bbce3cdc1a611f18.js" defer=""></script><script src="/_next/static/chunks/main-fd67a91ddc57a058.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4b39465f4354dcb6.js" defer=""></script><script src="/_next/static/chunks/655-8603e4094ac1d92b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-50c4cd13664290b3.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_buildManifest.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_ssgManifest.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="dark w-full h-full md:w-screen md: h-screen text-white"><div class="border-gray-200 border-b-2 drop-shadow-lg pt-3 sm:pb-8 w-full justify-between flex flex-row pr-3 h-10"> <div class="flex justify-beginning"><h1 class="text-red-400 font-bold text-md sm:text-xl pl-3"><a href="/">Rohit Musti</a></h1></div><div class="flex justify-end"><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">About</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Projects</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Blog</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Contact</button></div></div><div class="prose dark:prose-invert mx-auto max-w-2xl py-4"><h1>Valiating Databse Migrations</h1><p>Date Created: <!-- -->2024-10-16</p><div class=""><p>One of the most important skills I&#x27;ve learned in the past year at <a href="https://read.ai/">Read AI</a> is how to successfully run database migrations. After a particularly disastrous database migration in the fall of 2023, I decided to really focus on nailing this skill. First I needed to learn: I solicited advice and patterns from the many skilled engineers I&#x27;m lucky enough to call my colleagues. After spending some time observing, I completed several migrations myself. The goal of these migrations was to transfer sensitive settings from the initial generic table to a more dedicated table that significantly simplified adding new settings. Here is the pattern I arrived at!</p>
<h2>Understand the Initial Shape of the Data</h2>
<p>This doesn&#x27;t need to be anything fancy, I can usually throw together a few group by queries to get a sense of the all of the states a user can be in and the rough distribution of users across these states. Here is an example of what these queries might look:</p>
<pre><code>SELECT employer, COUNT(*) AS users_count 
FROM users
GROUP BY employer;
</code></pre>
<p>In this hypothetical, you are tasked with transferring the employer column from the users table to its own separate table. This query represents an easy way to get a sense of what the data looks like but it might be a little too granular. A more generic query might look like:</p>
<pre><code>SELECT 
    COUNT(*) AS all_users_count 
    COUNT(1) FILTER (WHERE employer IS NULL) as users_without_employers
    COUNT(1) FILTER (WHERE employer IS NOT NULL) as users_with_employers
FROM users
</code></pre>
<p>This tells us how much of the data is null. These are just a couple of examples of how you might go about undersatnding the shape of the data, but getting comfortable with SQL aggregation queries is an important component of these queries.</p>
<h2>Develop &quot;Validation&quot; Queries to Compare The State Pre and Post Migration</h2>
<p>The goal of these queries to quickly and easily validate that a migration has succeeded. It might look something like this:</p>
<pre><code>SELECT 
    COUNT(DISTINCT user_id) total_user_count,
    COUNT(1) FILTER (WHERE u.employer is not null) total_user_valid_employer_count,
    COUNT(1) FILTER (WHERE ue.employer = u.employer) AS matched_employer_count,
    COUNT(1) FILTER (WHERE ue.employer != u.employer) AS mismatched_employer_count,
    COUNT(1) FILTER (WHERE ue.employer IS NULL or u.employer IS NULL) AS null_employer_count,
FROM users u
LEFT JOIN user_employment ue ON ue.user_id = u.id
</code></pre>
<p>If the migration of the data from the hypothetical users table to the hypothetical user employer table succeeds, this query should have the final result of total user with a valid employer count equivalent to the matched employer count. This is also safe to run before you start migrating the data as it&#x27;ll just show up with zeros for matched and full counts for mismatched. Queries like these really help build confidence that you have not misconfigured the migration</p>
<h2>Execute the Migration and Validate</h2>
<p>At this point, you are ready to execute the migration. Run the migration! Bonus points if you can do it in a limited number of SQL queries. The fewer transactions required, the less likely something is going to go wrong. Sometimes you can&#x27;t avoid multiple queries or using cursors, but it&#x27;s usually safer to reach for those tools last.</p>
<h2>Optional: Read/Write to Both Tables Simultaneously</h2>
<p>A great technique to reduce overall risk is to write to both tables simultaneous as a part of the migration process. This is a great way to safely compare that the tables are remaining in sync. You can also easily log any discrepensies from queries in the application layer before completely transferring over to the new tables. Building that log analysis that everything is fine is an awesome way to verify that the data is still being queried and used in a safe way, not only testing that the database migration is correct but also testing that the new application logic is right.</p>
<h2>Conclusion</h2>
<p>This is just one pattern among many. In some cases it may be too heavy handed, but it&#x27;s become my go to approach when running migrations that move sensitive data from what table to another and my primary goals are correctness and reducing the effect on the user. Something extremely important to this pattern is a very high database querying skill level, building out fundamental database skills is the foundation of getting migrations right and something worth getting good at! It will pay dividends down the line.</p></div><hr/><p>See an error in this blog? Please reach out through my contact page and I will make a correction!</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"Valiating Databse Migrations","date":"2024-10-16"},"content":"\nOne of the most important skills I've learned in the past year at [Read AI](https://read.ai/) is how to successfully run database migrations. After a particularly disastrous database migration in the fall of 2023, I decided to really focus on nailing this skill. First I needed to learn: I solicited advice and patterns from the many skilled engineers I'm lucky enough to call my colleagues. After spending some time observing, I completed several migrations myself. The goal of these migrations was to transfer sensitive settings from the initial generic table to a more dedicated table that significantly simplified adding new settings. Here is the pattern I arrived at!\n\n## Understand the Initial Shape of the Data\n\nThis doesn't need to be anything fancy, I can usually throw together a few group by queries to get a sense of the all of the states a user can be in and the rough distribution of users across these states. Here is an example of what these queries might look:\n\n```\nSELECT employer, COUNT(*) AS users_count \nFROM users\nGROUP BY employer;\n```\n\nIn this hypothetical, you are tasked with transferring the employer column from the users table to its own separate table. This query represents an easy way to get a sense of what the data looks like but it might be a little too granular. A more generic query might look like:\n\n```\nSELECT \n    COUNT(*) AS all_users_count \n    COUNT(1) FILTER (WHERE employer IS NULL) as users_without_employers\n    COUNT(1) FILTER (WHERE employer IS NOT NULL) as users_with_employers\nFROM users\n```\n\nThis tells us how much of the data is null. These are just a couple of examples of how you might go about undersatnding the shape of the data, but getting comfortable with SQL aggregation queries is an important component of these queries.\n\n## Develop \"Validation\" Queries to Compare The State Pre and Post Migration\n\nThe goal of these queries to quickly and easily validate that a migration has succeeded. It might look something like this:\n\n```\nSELECT \n    COUNT(DISTINCT user_id) total_user_count,\n    COUNT(1) FILTER (WHERE u.employer is not null) total_user_valid_employer_count,\n    COUNT(1) FILTER (WHERE ue.employer = u.employer) AS matched_employer_count,\n    COUNT(1) FILTER (WHERE ue.employer != u.employer) AS mismatched_employer_count,\n    COUNT(1) FILTER (WHERE ue.employer IS NULL or u.employer IS NULL) AS null_employer_count,\nFROM users u\nLEFT JOIN user_employment ue ON ue.user_id = u.id\n```\n\nIf the migration of the data from the hypothetical users table to the hypothetical user employer table succeeds, this query should have the final result of total user with a valid employer count equivalent to the matched employer count. This is also safe to run before you start migrating the data as it'll just show up with zeros for matched and full counts for mismatched. Queries like these really help build confidence that you have not misconfigured the migration\n\n## Execute the Migration and Validate\n\nAt this point, you are ready to execute the migration. Run the migration! Bonus points if you can do it in a limited number of SQL queries. The fewer transactions required, the less likely something is going to go wrong. Sometimes you can't avoid multiple queries or using cursors, but it's usually safer to reach for those tools last.\n\n## Optional: Read/Write to Both Tables Simultaneously\n\nA great technique to reduce overall risk is to write to both tables simultaneous as a part of the migration process. This is a great way to safely compare that the tables are remaining in sync. You can also easily log any discrepensies from queries in the application layer before completely transferring over to the new tables. Building that log analysis that everything is fine is an awesome way to verify that the data is still being queried and used in a safe way, not only testing that the database migration is correct but also testing that the new application logic is right.\n\n## Conclusion\n\nThis is just one pattern among many. In some cases it may be too heavy handed, but it's become my go to approach when running migrations that move sensitive data from what table to another and my primary goals are correctness and reducing the effect on the user. Something extremely important to this pattern is a very high database querying skill level, building out fundamental database skills is the foundation of getting migrations right and something worth getting good at! It will pay dividends down the line.\n\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"validating-database-migrations"},"buildId":"9akIhXmleYhdDAfhYnJ16","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>