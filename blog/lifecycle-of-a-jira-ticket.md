---
title: "The Lifecycle of a Jira Ticket"
date: "2025-01-01"
---

As I have been mentoring other software engineers,
I've started to crystalize a few thoughts about the lifecycle of the most base unit of work at modern tech companies: jira tickets.

1. *Identifying the Problem*. Most Jira ticket's have a core problem and well written jira tickets make that abundantly clear. However, all to often, details sparse (if given at all) and a non-trivial part of an engineer's job is connecting their jira tickets to the underlying business problem it is trying to solve so that they can make sure they solve it correctly. If you don't understand the core problem you are solving and cannot connect it to a meaningful part of the underlying business strategy, you might want to push back against the powers that be because it might not be a worthwhile problem.
2. *Build Context*. Through identifying the problem you will have built some context, but may not have a complete mental model of how the entire system you are working within operates. Building out an understanding of the system you are working in will help you create a solution that builds on the work of all of those that came before you, fitting neatly into the contours of the codebase. If you fail to do this, you may find yourself pushing hard against the headwinds of previous code.
3. *Identify the Best Solution*. The best solution will probably not be your first guess. Over time, you may develop better instincts, but early on it's worth considering several potential solutions. A technique I've used is asking myself the question: "if I came across this code in the wild, would I want to rewrite it or would I want to emulate it?". It's never easy, and a good sign of growth is looking at your past work with a tinge of embarassment as you see all of the gaps in the solution that you can see now that you missed then.
4. *Write Tests to Validate Your Solution Works*. If you cannot write tests to validate that your solution works, it's worth asking if you solved it the write way. I've made the excuse myself, and heard it many more times, "there weren't tests before so why do we need tests now?". With software, we have this wonderful opportunity to literally double validate our work through automated tests. Given that we cannot physically inspect or touch our work physically, it's incredibly important that we test it as thoroughly as we can. I've also begun to use tests as a tool to define the possible behavior of a function to prevent other engineers in the future accidentally breaking it because they were missing some crucial context.
5. *Deploy and Monitor Your Solution in Production*. Once you have deployed your solution, it is important to monitor it. Too often, we click deploy and move on, only to have the client success team tap our shoulder in three weeks with a stack full of customer complaints that something isn't working. Embarassed, we scramble to add the missing database update or redirect HTTP request. All of that can be prevented if we hand validate a few production examples of the code working in the wild. Recently, a colleague of mine was validating their solution worked and they were relying on logs appearing. Super reasonable! But they weren't also validating that the database was being updated. Low and behold, the database was not updating and there ended up being a misconfigured database connection. These are the kind of small mistakes that we are never immune to, especially as we adopt the latest and greatest technologies. The only way to catch this stuff is to test it thoroughly. At the end of the day, if you are successful in your career, you might find yourself at the helm of a company, then the buck really stops with you. Building that sense of ownership and responsibility early on will supercharge your growth and career.
