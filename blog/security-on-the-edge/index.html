<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2bbc0921d5656d23.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2bbc0921d5656d23.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-45f9f9587e6c08e1.js" defer=""></script><script src="/_next/static/chunks/framework-bbce3cdc1a611f18.js" defer=""></script><script src="/_next/static/chunks/main-fd67a91ddc57a058.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4b39465f4354dcb6.js" defer=""></script><script src="/_next/static/chunks/655-8603e4094ac1d92b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-50c4cd13664290b3.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_buildManifest.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_ssgManifest.js" defer=""></script><script src="/_next/static/9akIhXmleYhdDAfhYnJ16/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="dark w-full h-full md:w-screen md: h-screen text-white"><div class="border-gray-200 border-b-2 drop-shadow-lg pt-3 sm:pb-8 w-full justify-between flex flex-row pr-3 h-10"> <div class="flex justify-beginning"><h1 class="text-red-400 font-bold text-md sm:text-xl pl-3"><a href="/">Rohit Musti</a></h1></div><div class="flex justify-end"><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">About</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Projects</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Blog</button><button class="font-bold hover:underline text-md sm:text-xl text-red-400 px-1">Contact</button></div></div><div class="prose dark:prose-invert mx-auto max-w-2xl py-4"><h1>Security on the Edge</h1><p>Date Created: <!-- -->2023-01-17</p><div class=""><p>As a software engineer at <a href="https://read.ai/">Read AI</a>, I recently had the opportunity to design an authenticaction system for accessing video recordings served through AWS Cloudfront. I was incredibly excited to apply my skills as a cryptographer to this real world problem. This is the sort of real world problem that I had spent hours trying to simulate through homework assignments I created for my students. To any other cryptography instructors, feel free to use the brief!</p>
<h2>Prompt</h2>
<p>You are a software engineer at start up.
You need to serve a video recording through AWS Cloudfront.
The benefit of serving through a CDN is that it ensures caching in global regions so that all of our cutomers have speedy video streaming! Your system should prserve this performance benefit.</p>
<ol>
<li>We also only want only customers to be able to load the recordings of videos they are authorized for.</li>
<li>The system needs to also preserve as much of the original speed of the cache as possible</li>
</ol>
<h2>My approach</h2>
<p>When a customer requests access to a video recording, after verifying they have access to the recording, we issue them a token. Encoded in this token is the recording ID and the expiration datetime (3 hours after issuance). This token contains a signed hash. The final token structure is:</p>
<p><code>&lt;token_encoding_method&gt;.&lt;base64_encoded_token&gt;.&lt;Hash(token_encoding_method, base64_encoded_token_information, secret_key)&gt;</code></p>
<p>The customer can then hit our recordings end point and present the token. We then take advantage of lambda edge functions to verify the request coming into cloudfront. To verify the token is valid, we access our secret key and compute the hash on the token encoding method and base 64 encoded token and verify it matches the hash signature on the token. If the request is invalid, we throw an error and prevent the user from accessing the cached recording; if the token is valid, we pass their request through</p>
<h2>Cryptographic Primtives</h2>
<p>This is a HMAC system. If you are interested in learning more about HMAC systems, check out my slides from a <a href="https://rohitmusti.github.io/intro-to-crypto/">cryptography class</a> I taught at CUNY. We do leak information about the information inside of the token - the recording id and expiration datetime - but none of that information is secret. Additionally, the point of the system is to make sure the user authenticated to our system. not to hide information contained in the token. The security system guarantees that we at Read AI issued the token allowing the bearer to access a specific recording for an allotted period of time. Therefore, only authorized users can access a recording. This system is also stateless, it only relies upon access to a secret key and doesn&#x27;t require any database calls. This makes it very fast.</p>
<h2>Did we meet the brief?</h2>
<p>Security: Only we at Read AI have access to the secret key used for encryption and we periodically rotate the key. This ensures that no one can forge a signature. We also entrust the actual hashing and comparison logic to the <a href="https://jwt.io/">jwt</a> library, following the golden rule of never rolling your own security.</p>
<p>Speed: This implementation relies upon a hash function, string, and integer comparisons. These are all extremely fast operations that do not add significant time to the request of resources through the CDN.</p>
<h2>Implementation Curiosities</h2>
<ul>
<li>
<p>By declaring secrets outside of the main body function, it would only be run once on initialization, not everytime the function was run. This translates to only retrieving the JWT secret once on deploy/intiialization instead of on every function run. This means we don&#x27;t need to make the round trip call to AWS Secrets Manager every time we want to authenticate!</p>
</li>
<li>
<p>Where are my logs? Even though lambda edge function are deployed to <code>us-east-1</code>, their logs populate in whichever region the requests are made. For a while, I was making requests in <code>us-west-2</code> and going mad trying to find them in <code>us-east-1</code>! Surprisingly, this was the most time consuming and frustrating part of the process.</p>
</li>
</ul></div><hr/><p>See an error in this blog? Please reach out through my contact page and I will make a correction!</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"Security on the Edge","date":"2023-01-17"},"content":"\nAs a software engineer at [Read AI](https://read.ai/), I recently had the opportunity to design an authenticaction system for accessing video recordings served through AWS Cloudfront. I was incredibly excited to apply my skills as a cryptographer to this real world problem. This is the sort of real world problem that I had spent hours trying to simulate through homework assignments I created for my students. To any other cryptography instructors, feel free to use the brief!\n\n## Prompt\n\nYou are a software engineer at start up.\nYou need to serve a video recording through AWS Cloudfront.\nThe benefit of serving through a CDN is that it ensures caching in global regions so that all of our cutomers have speedy video streaming! Your system should prserve this performance benefit.\n\n1. We also only want only customers to be able to load the recordings of videos they are authorized for.\n1. The system needs to also preserve as much of the original speed of the cache as possible\n\n## My approach\n\nWhen a customer requests access to a video recording, after verifying they have access to the recording, we issue them a token. Encoded in this token is the recording ID and the expiration datetime (3 hours after issuance). This token contains a signed hash. The final token structure is:\n\n`\u003ctoken_encoding_method\u003e.\u003cbase64_encoded_token\u003e.\u003cHash(token_encoding_method, base64_encoded_token_information, secret_key)\u003e`\n\nThe customer can then hit our recordings end point and present the token. We then take advantage of lambda edge functions to verify the request coming into cloudfront. To verify the token is valid, we access our secret key and compute the hash on the token encoding method and base 64 encoded token and verify it matches the hash signature on the token. If the request is invalid, we throw an error and prevent the user from accessing the cached recording; if the token is valid, we pass their request through\n\n## Cryptographic Primtives\n\nThis is a HMAC system. If you are interested in learning more about HMAC systems, check out my slides from a [cryptography class](https://rohitmusti.github.io/intro-to-crypto/) I taught at CUNY. We do leak information about the information inside of the token - the recording id and expiration datetime - but none of that information is secret. Additionally, the point of the system is to make sure the user authenticated to our system. not to hide information contained in the token. The security system guarantees that we at Read AI issued the token allowing the bearer to access a specific recording for an allotted period of time. Therefore, only authorized users can access a recording. This system is also stateless, it only relies upon access to a secret key and doesn't require any database calls. This makes it very fast.\n\n## Did we meet the brief?\n\nSecurity: Only we at Read AI have access to the secret key used for encryption and we periodically rotate the key. This ensures that no one can forge a signature. We also entrust the actual hashing and comparison logic to the [jwt](https://jwt.io/) library, following the golden rule of never rolling your own security.\n\nSpeed: This implementation relies upon a hash function, string, and integer comparisons. These are all extremely fast operations that do not add significant time to the request of resources through the CDN.\n\n## Implementation Curiosities\n\n- By declaring secrets outside of the main body function, it would only be run once on initialization, not everytime the function was run. This translates to only retrieving the JWT secret once on deploy/intiialization instead of on every function run. This means we don't need to make the round trip call to AWS Secrets Manager every time we want to authenticate!\n\n- Where are my logs? Even though lambda edge function are deployed to `us-east-1`, their logs populate in whichever region the requests are made. For a while, I was making requests in `us-west-2` and going mad trying to find them in `us-east-1`! Surprisingly, this was the most time consuming and frustrating part of the process.\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"security-on-the-edge"},"buildId":"9akIhXmleYhdDAfhYnJ16","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>